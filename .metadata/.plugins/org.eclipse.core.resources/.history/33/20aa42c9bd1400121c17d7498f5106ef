# Create your views here.
from globalHeader import *
from django.shortcuts import get_object_or_404, render_to_response
from django.template import Context, loader, RequestContext
from django.http import HttpResponse, HttpResponseRedirect
from myevents.models import * 
from myevents.forms  import IndexForm, AdminFixedForm, VoteForm
from django.forms.fields import ChoiceField, MultipleChoiceField
from django.utils import simplejson
from django.core import serializers
import urllib2 
import unicodedata
import MySQLdb

def adminChoice(request, ehash):
	if 'user_id' not in request.session:
		return render_to_response('myevents/error.html', {'message':'This session is expired'}, context_instance=RequestContext(request))
	else:
		uid = request.session['user_id']
        u = get_user_by_uid(uid)
        if u is not None and u.is_authenticated(): 
            try:
                e = event.objects.get(ehash=ehash)
                if int(e.status) < EVENT_STATUS.HASDETAIL:
                    data = {'message': 'Please Provide Event Detail First'}
                    return render_to_response('myevents/error.html', data, context_instance=RequestContext(request))
                if int(e.status) == EVENT_STATUS.VOTING:
                    started = True
                else:
                    started = False
            
                has_recommendation = False
                if isValidForRecommendation(e.eventDate,e.location):
                    has_recommendation = True
                    
                print has_recommendation
                data = {'event':e, 'user':u,'uhash':u.uhash, 'started':started,'has_recommendation':has_recommendation}
                return render_to_response('myevents/adminChoice.html', data, context_instance=RequestContext(request))
            except event.DoesNotExist:
                data = {'message': 'event does not exist'}
                return render_to_response('myevents/error.html', data, context_instance=RequestContext(request))
        else:
            return render_to_response('myevents/error.html', {'message':'invalid user'}, context_instance=RequestContext(request))


def addManualChoice(request, ehash):
	if 'user_id' not in request.session:
		return render_to_response('myevents/error.html', {"message":"invalid user, please log in"}, context_instance=RequestContext(request))
	
	if request.method == "POST":
		try:
			e = event.objects.get(ehash=ehash) 
			uid = request.session['user_id']
			u = user.objects.get(id=uid)
			name = request.POST.get('name', '')
			location = request.POST.get('location', '')
			notes = request.POST.get('notes', '')
			try:
				### if this particular user already added the entry before, update the entry 
				c = manual.objects.get(name=name, addby_id=u.id)
				c.location = location
				c.notes = notes
				c.save()
				newitem = item.objects.get(foreign_id=c.id, ftype=CHOICE_SOURCE.MANUAL)
			except manual.DoesNotExist:
				c = manual.objects.create(name=name, location=location, notes=notes, addby_id=u.id) 
				newitem = item.objects.create(foreign_id=c.id, name=c.name, location=c.location, image=None,notes=c.notes,url=None,ftype=CHOICE_SOURCE.MANUAL)
			json = simplejson.dumps({"choice_id":newitem.id, "choice_name":c.name, "choice_location":c.location, "choice_notes":c.notes})
			return HttpResponse(json, mimetype='application/json')
		except event.DoesNotExist or user.DoesNotExist:
			json = simplejson.dumps({"choice":None})
			return HttpResponse(json, mimetype='application/json')
	else:
		return render_to_response('myevents/error.html', {"message":"the request is not a post"}, context_instance=RequestContext(request))

        
def addManualChoice2(request, ehash, uhash):
    if request.method == "POST":
        try:
            e = event.objects.get(ehash=ehash) 
            u = user.objects.get(uhash=uhash)
            name = request.POST.get('name', '')
            location = request.POST.get('location', '')
            notes = request.POST.get('notes', '')
            try:
                ### if this particular user already added the entry before, update the entry 
                c = manual.objects.get(name=name, addby_id=u.id)
                c.location = location
                c.notes = notes
                c.save()
                newitem = item.objects.get(foreign_id=c.id, ftype=CHOICE_SOURCE.MANUAL)
            except manual.DoesNotExist:
                c = manual.objects.create(name=name, location=location, notes=notes, addby_id=u.id) 
                newitem = item.objects.create(foreign_id=c.id, name=c.name, location=c.location, image=None,notes=c.notes,url=None,ftype=CHOICE_SOURCE.MANUAL)
            
            json = simplejson.dumps({"choice_id":newitem.id, "choice_name":c.name, "choice_location":c.location, "choice_notes":c.notes})
            return HttpResponse(json, mimetype='application/json')
        except event.DoesNotExist or user.DoesNotExist:
            json = simplejson.dumps({"choice":None})
            return HttpResponse(json, mimetype='application/json')
    else:
        return render_to_response('myevents/error.html', {"message":"the request is not a post"}, context_instance=RequestContext(request))

# out of date.. needs double check 8/31/2012
def addSearchChoice(request, ehash, uhash):
    if request.method == "POST":
        try:
            e = event.objects.get(ehash=ehash) 
            u = user.objects.get(uhash=uhash)
            name = request.POST.get('name', '')
            location = request.POST.get('location', '')
            notes = request.POST.get('notes', '')
            longtitude= request.POST.get('longtitude', '')
            latitude = request.POST.get('latitude','')
            url = request.POST.get('url','')
            rating = request.POST.get('rating','')
            reviewcount = request.POST.get('review_count','')
            query = request.POST.get('query','')
            what = ','.join(e.detail,e.what_other)
            zipcode = request.POST.get('zipcode','')
            
            try:
                ### if this particular user already added the entry before, update the entry 
                c = yelp.objects.get(name=name,location=location)
                c.rating = rating
                c.reviewcount = reviewcount 
                c.save()
            except yelp.DoesNotExist:
                c = manual.objects.create(name=name, location=location, notes=notes, addby_id=u.id) 
            json = simplejson.dumps({"choice_id":c.id, "choice_name":c.name, "choice_location":c.location, "choice_notes":c.notes})
            return HttpResponse(json, mimetype='application/json')
        except event.DoesNotExist or user.DoesNotExist:
            json = simplejson.dumps({"choice":None})
            return HttpResponse(json, mimetype='application/json')
    else:
        return render_to_response('myevents/error.html', {"message":"the request is not a post"}, context_instance=RequestContext(request))

def getMyPastChoices(request, ehash, uhash):
    if request.method == 'GET':
        u = user.objects.get(uhash=uhash)
        cs = choice.objects.filter(addby_id=u.id)
        
        ### TBD: only pick the most frequent five.
        data = serializers.serialize('json', cs)        
        return HttpResponse(data, mimetype='application/json')
    else:
        return render_to_response('myevents/error.html', {"message":"the request is not a get"}, context_instance=RequestContext(request))
    
    

def search_yelp(category,query,location,query_id):
    url_params={}
    if type(query) is unicode:
        url_params['term'] = unicodedata.normalize('NFKD', query).encode('ascii','ignore') 
    else:
        url_params['term'] = query
    url_params['location'] = location
    url_params['limit'] = "10"
    url_params['radius_filter'] = "3800"
    url_params['category_filter'] = category

    consumer_key = '4cJ1ZEMrBdiv4pFLj8AtDA'
    consumer_secret = '93EEwlZWhuzx2TrZzXWf847RFNE'
    token =  'CgZGSsOcAQ1nD6J8WIcKZi4up_mDflsw'
    token_secret =  'nwYBgTQb112p4j9F5_BqrP2iLlw'

    response = yelp_request("api.yelp.com", '/v2/search', url_params, consumer_key, consumer_secret,  token,  token_secret)
    
    t0 = time.time() 
    ys=[]
    # returned error
    if not response.has_key('businesses'):
        return  serializers.serialize('json', {}, indent=2, use_natural_keys=True)
    #parse yelp result
    for eachresult in response['businesses']:
        #must have a name
        if eachresult.has_key('name'):    
            name = eachresult['name'] 
            try:
                y = yelp.objects.get(name=name)
            except yelp.DoesNotExist:
                y = yelp.objects.create(name=name)
            if eachresult.has_key('id'):    
                y.yid = eachresult['id']
            if eachresult.has_key('image_url'):    
                y.image_url = eachresult['image_url']
            if eachresult.has_key('url'):    
                y.url = eachresult['url']
            if eachresult.has_key('mobile_url'):    
                y.mobile_url = eachresult['mobile_url']
            if eachresult.has_key('phone'):    
                y.phone = eachresult['phone']
            if eachresult.has_key('display_phone'):    
               y.display_phone = eachresult['display_phone']
            if eachresult.has_key('review_count'):    
                y.review_count = eachresult['review_count']
            if eachresult.has_key('categories'):         
                cls = []
                for c in eachresult['categories']:
                    cl = ','.join(c)
                    cls.append(cl)
                y.categories = ';'.join(cls)    
            if eachresult.has_key('rating'):    
                y.rating = eachresult['rating']    
            if eachresult.has_key('rating_img_url'):        
                y.rating_img_url = eachresult['rating_img_url']
            if eachresult.has_key('rating_img_url_small'):        
                y.rating_img_url_small= eachresult['rating_img_url_small'] 
            if eachresult.has_key('rating_img_url_large'):        
                y.rating_img_url_large = eachresult['rating_img_url_large']
            if eachresult.has_key('snippet_text'):        
                y.snippet_text = eachresult['snippet_text']
            if eachresult.has_key('snippet_img_url'):        
                y.snippet_img_url = eachresult['snippet_img_url']
           
            if eachresult.has_key('location'):
                local = eachresult['location']
                if local.has_key('address'):
                    y.location_address =  ','.join(local['address'])
                if local.has_key('city'):
                    y.location_city =  local['city']
                if local.has_key('coordinate'):
                    y.location_coordinate_latitude =  local['coordinate']['latitude']    
                    y.location_coordinate_longitude = local['coordinate']['longitude']    
                if local.has_key('country_code'):
                    y.location_country_code= local['country_code']    
                if local.has_key('display_address'):
                    y.location_display_address = ','.join(local['display_address'])
                if local.has_key('postal_code'):
                    y.location_postal_code =  local['postal_code']
                if local.has_key('geo_accuracy'):
                    y.location_geo_accuracy =  local['geo_accuracy']

        y.save()
        
        location=y.location_display_address
        try:
            newitem = item.objects.get(foreign_id=y.id,ftype=CHOICE_SOURCE.YELP)
        except item.DoesNotExist:
            #add image field
            newitem = item.objects.create(foreign_id=y.id, name=y.name, location=location, image=y.rating_img_url,notes=y.review_count,url=y.url,ftype=CHOICE_SOURCE.YELP)
        ys.append(newitem)
        # record this result results, store new item id or yelp id?????
        s = search_result.objects.create(query_id=query_id, yelp_result_id = newitem.id)
    print 'parse yelp result spent:', time.time()-t0  
    return  serializers.serialize('json', ys, indent=2, use_natural_keys=True)
    
# output: temporal returns for suggestions
def getMyYelpChoices(request, ehash, uhash):
    if request.method == 'GET':
        u = user.objects.get(uhash=uhash) 
        e = event.objects.get(ehash=ehash)
        data = {}
        
        q = search_query.objects.create(term=e.detail,location=e.location, search_by_id = u.id, search_for_id=e.id)
        if e.location:
            if e.detail == "dining out":
                data = search_yelp('restaurants','restaurants',e.location,q.id)
            if e.detail == "drink":
                data = search_yelp('nightlife','bar',e.location,q.id)     
        return HttpResponse(data, mimetype='application/json')
    else:
        return render_to_response('myevents/error.html', {"message":"the request is not a get"}, context_instance=RequestContext(request))
 
# get the rating of the user for the place cid
def get_baseline_rating(uid, cid):
    p = poll.objects.filter(user_id = uid, choice_id = cid);
    flatsum = 0
    num = len(p)
    if num>0:
        for row in p:
            flatsum += row.vote
        return float(flatsum)/num
    else:
        return None  #if the user haven't voted the place(choice) before
    
def find_list_intersection(a,b):
    return set(a).intersection( set(b) )

#input list: compute mean and dev
def aggregate_rating(ratings):
    list_size = len(ratings)
    flatsum = 0.0
    squaresum = float(0)
    for r in ratings:
        flatsum += r
    mean = flatsum/list_size
    if list_size>1:
        for r in ratings:
            squaresum += (r-mean)**2
        variance = squaresum/(list_size - 1)
    else:
        variance = 0.0
    return  (flatsum,variance)
      
def sort_items_by_score(mydict):
    itemlist = []
    newdict = sorted(mydict.iteritems(), key=lambda (k,v): (v,k), reverse=True)
    for k,v in newdict:
        #print "%s: %s" % (k,v)
        if v>0:
            itemlist.append(k)
    return itemlist
    
# input dict: key uid, value <item,rating> dict 
def build_baseline_reclist(user_rate):
    ulist = user_rate.values()
    item_union = {}
    for u in ulist:
        #u.keys= items. 
        for iid,rating in u.iteritems():
            if item_union.has_key(iid):
                item_union[iid].append(rating)
            else:
                item_union[iid]=[]
                item_union[iid].append(rating)
    #item_iid = []
    #item_score = []
    item_score_dict = {}
    for item in item_union.keys():
        values = item_union[item]
        #item_iid.append(item)
        (flatsum,var) = aggregate_rating(values)
        #item_score.append(0.9*mean-0.1*var)
        item_score_dict[item] = 0.9*flatsum - 0.1*var
    
    #sort item based on its score
    sorted_items=[]
    sorted_items = sort_items_by_score(item_score_dict)
    return sorted_items

# work in july 19. 
# baseline recommendation algorithm
def getBaseRecommendation2(request,ehash,uhash):
    #print ehash,uhash
    if request.method == 'GET':
        u = user.objects.get(uhash=uhash)
        e = event.objects.get(ehash=ehash)
        data = {}
        # select all users of this event 
        eu = event_user.objects.filter(event_id=e.id)
        if eu:
            user_rate = {}
            for row in eu:
                uid = row.user_id
                # for this user, select past positive ratings, build the dictionary of item:rating
                iu = poll.objects.filter(user_id=uid)
                if iu:  #user has voted before.
                    user_rate[uid] = {}     #build the rating list for the user
                    for i in iu:
                        cid = i.choice_id 
                        rating = get_baseline_rating(uid,cid)
                        # get the item id according to choice id.
                        item_id = None
                        try:
                            item_id = choice.objects.get(id=cid).pickid
                        except choice.DoesNotExist:
                            print 'can not find the choice??'
                        if (rating!=None) and item_id:
                            user_rate[uid][item_id] = rating
            if user_rate:
                sorted_items =[]
                sorted_items = build_baseline_reclist(user_rate) 
                #print 'sorted_items:%s'%','.join(sorted_items)
                ys = []                                                                                       
                item_count = 0 
                for i in sorted_items:
                    #print i
                    if item_count > 10:   # only recommend top 10 items
                        break
                    try:
                        item_instance = item.objects.get(id = i)
                        #print item_instance
                        ys.append(item_instance)
                        item_count += 1
                    except item.DoesNotExist:
                        print 'can not find the past item ??'
                data = serializers.serialize('json', ys, indent=2, use_natural_keys=True) 
            else:  #if nobody has rated before
                q = search_query.objects.create(term=e.detail,location=e.location, search_by_id = u.id, search_for_id=e.id)
                data = search_yelp('restaurants','restaurants',e.location,q.id)
            return HttpResponse(data, mimetype='application/json')
        else:  # no users in the event
            return render_to_response('myevents/error.html', {"message":" failed to identify your friends"}, context_instance=RequestContext(request))
    else:
        return render_to_response('myevents/error.html', {"message":"the request is not a get"}, context_instance=RequestContext(request))

def getSearchChoices(request,ehash,uhash=None):
    #print ehash,uhash
	if request.method == 'POST':
		e = event.objects.get(ehash=ehash)
		mv_title = request.POST.get('mv_title', '')
		th_name = request.POST.get('th_name','')
		zipcode = request.POST.get('zipcode','')
		query_date = str(e.eventDate)
		conn = MySQLdb.connect(host = "localhost",user = "root", passwd = "fighting123", db = "mymovies")
		
		cursor = conn.cursor()
		if th_name and mv_title :
			query = 'select s.id, m.title, t.name, t.street,t.city,t.state,t.postcode, t.url, s.showtimes from myevents_movie m, myevents_theatre t, myevents_schedule s where t.thid = s.thid and s.mov_id = m.mov_id and t.postcode = "'+zipcode+'" and s.date = "'+query_date+'" and m.title ="'+mv_title+'" and t.name="' +th_name+'"' 
		else:
			if mv_title: 
				query = 'select s.id, m.title, t.name, t.street,t.city,t.state,t.postcode, t.url, s.showtimes from myevents_movie m, myevents_theatre t, myevents_schedule s where t.thid = s.thid and s.mov_id = m.mov_id and t.postcode = "'+zipcode+'" and s.date = "'+query_date+'" and m.title ="'+mv_title+'"' 
			if th_name:
				query = 'select s.id, m.title, t.name, t.street,t.city,t.state,t.postcode, t.url, s.showtimes from myevents_movie m, myevents_theatre t, myevents_schedule s where t.thid = s.thid and s.mov_id = m.mov_id and t.postcode = "'+zipcode+'" and s.date = "'+query_date+'" and t.name="' +th_name+'"' 
			
		print query
		cursor.execute(query)
		rs = cursor.fetchall()
		print rs
		conn.close()
		ys = {}
		i=0
		for row in rs:
			print row[0],row[1],row[2]
			address = row[3] +' '+ row[4] +' '+row[5]+' '+ row[6] 
			y = {}
			y['schedule_id'] = row[0]
			y['movie_title'] = row[1] 
			y['theatre_name'] = row[2]
			y['theatre_address'] = address
			y['theatre_url'] = row[7]
			y['showtimes'] = row[8]
			ys[str(i)]=y
			i+=1
				
			#seralized_dict = simplejson.dumps(ys, default=lambda a: "[%s,%s]" % (a, a))
		data = simplejson.dumps(ys)
			#data = serializers.serialize('json', ys, indent=2, use_natural_keys=True) 
		return HttpResponse(data, mimetype='application/json')
	else:
		return render_to_response('myevents/error.html', {"message":"the request is not a POST"}, context_instance=RequestContext(request))


def getBaseRecommendation(request,ehash,uhash=None):
    #print ehash,uhash
	if request.method == 'GET':
		e = event.objects.get(ehash=ehash)
		query_date = str(e.eventDate)
		query_zipcode = e.location

		conn = MySQLdb.connect(host = "localhost",user = "root", passwd = "fighting123", db = "mymovies")
		cursor = conn.cursor()
		if query_date and query_zipcode:
			query = 'select s.id, m.title, t.name, t.street,t.city,t.state,t.postcode, t.url, s.showtimes  from  myevents_movie m, myevents_theatre t, myevents_schedule s where t.thid = s.thid and s.mov_id = m.mov_id and t.postcode = "'+query_zipcode+'" and s.date = "'+query_date+'"'
			print query
			cursor.execute(query)
				
			rs = cursor.fetchall()
			print rs
			conn.close()
			ys = {}
			i=0
			for row in rs:
				print row[0],row[1],row[2]
				address = row[3] +' '+ row[4] +' '+row[5]+' '+ row[6] 
				y = {}
				y['schedule_id'] = row[0]
				y['movie_title'] = row[1] 
				y['theatre_name'] = row[2]
				y['theatre_address'] = address
				y['theatre_url'] = row[7]
				y['showtimes'] = row[8]
				ys[str(i)]=y
				i+=1
				
			#seralized_dict = simplejson.dumps(ys, default=lambda a: "[%s,%s]" % (a, a))
			data = simplejson.dumps(ys)
			#data = serializers.serialize('json', ys, indent=2, use_natural_keys=True) 
			return HttpResponse(data, mimetype='application/json')
		else:
			return render_to_response('myevents/error.html',{"message":"the zipcode and query date should not be empty"}, context_instance=RequestContext(request))
	else:
		return render_to_response('myevents/error.html', {"message":"the request is not a GET"}, context_instance=RequestContext(request))

#select from search results
def getMyYelpSearchChoices(request,ehash):
	if 'user_id' not in request.session:
		return render_to_response('myevents/error.html', {"message":"the session is not valid"}, context_instance=RequestContext(request))
	else:
		if request.method=="POST":
			uid = request.session['user_id']
			e = event.objects.get(ehash=ehash)
			u= user.objects.get(id=uid)
			data = {}
			query_term = request.POST.get('query')
			location = request.POST.get('location')
		
		#record query behavior, what if one user, for one event, searched twice??? record them but be careful when pulling out the results
			q = search_query.objects.create(term=query_term,location=location, search_by_id = u.id, search_for_id=e.id)
			if e.detail == 'dining out':
				data = search_yelp('restaurants',query_term,location, q.id)
			if e.detail == 'drink':
				data = search_yelp('nightlife',query_term,location, q.id)
		#for d in data:
		#    s = search_result.objects.create(query_id=q.id, yelp_result_id=d.id)
		#return to client, render search results 
			return HttpResponse(data, mimetype='application/json')
		else:
			return render_to_response('myevents/error.html', {"message":"the request is not a get"}, context_instance=RequestContext(request))

#select from search results
def getMyYelpSearchChoices2(request,ehash,uhash):
    if request.method=="POST":
        e = event.objects.get(ehash=ehash)
        u= user.objects.get(uhash=uhash)
        data = {}
        query_term = request.POST.get('query')
        location = request.POST.get('location')
        
        #record query behavior, what if one user, for one event, searched twice??? record them but be careful when pulling out the results
        q = search_query.objects.create(term=query_term,location=location, search_by_id = u.id, search_for_id=e.id)
        if e.detail == 'dining out':
            data = search_yelp('restaurants',query_term,location, q.id)
        if e.detail == 'drink':
            data = search_yelp('nightlife',query_term,location, q.id)
        #for d in data:
        #    s = search_result.objects.create(query_id=q.id, yelp_result_id=d.id)
        #return to client, render search results 
        return HttpResponse(data, mimetype='application/json')
    else:
        return render_to_response('myevents/error.html', {"message":"the request is not a get"}, context_instance=RequestContext(request))
    
# use item rather than different types
def editEventChoice(request, ehash,uhash=None):
    if request.method == "POST":
        admin_choices = request.POST.getlist('admin_choice_ids')
        try: 
            choice_objs = []
            e = event.objects.get(ehash=ehash)
            if uhash is None:
                uid = request.session['user_id']
                if uid is None:
                    return render_to_response('myevents/error.html', {"message":"invalid user"}, context_instance=RequestContext(request))      
                else:
                    inviter = user.objects.get(id=uid)
            else:
                inviter = user.objects.get(uhash=uhash)
            for cid in admin_choices:
                try:
                    c = choice.objects.get(pickid=cid,pickby_id=inviter.id)
                    c.cnt+=1
                    c.save()
                except choice.DoesNotExist:
                    c = choice.objects.create(pickid=cid, pickby_id=inviter.id,cnt=1) 
                try: # here is for wrong operation. shouldn't happen if not because of testing
                    ec = event_choice.objects.get(event_id= e.id,choice_id=c.id)
                except:
                    ec = event_choice.objects.create(event_id=e.id, choice_id=c.id)
                item_obj = item.objects.get(id=cid)
                choice_objs.append(item_obj)
                    
            ### send a mail to inviter too, since he is the attender as well
            attenderMail(ehash, inviter.uhash, inviter.email, e.name, inviter.email)
            
            ### get all friends email
            attenders = e.friends.strip()
            all_attenders = attenders.split(',')

            ### send email to each attender 
            for each_attender in all_attenders:
                #remove space
                each_attender = each_attender.strip()    
                try:
                    attender = user.objects.get(email=each_attender)
                    attenderMail(ehash, attender.uhash, inviter.email, e.name, attender.email)
                except user.DoesNotExist:   #ignore the user which doesn't exist in the db
                    continue
              
            e.status = EVENT_STATUS.VOTING
            e.save()
            data = {'event': e, 'user':inviter,'choices':choice_objs}        
            return render_to_response('myevents/success.html', data, context_instance=RequestContext(request))
        except event.DoesNotExist or user.DoesNotExist:
            return render_to_response('myevents/error.html', {"message":"event does not exist"}, context_instance=RequestContext(request))      

#attender add more choice. form update
def addMoreChoice(request,ehash,uhash):
    if request.method == "POST":
        attender_choices = request.POST.getlist('attender_choice_ids')
        try: 
            choice_objs = []
            e = event.objects.get(ehash=ehash)
            proposer = user.objects.get(uhash=uhash)
            for cid in attender_choices:
                try:
                    c = choice.objects.get(pickid=cid,pickby_id=proposer.id)
                    c.cnt+=1
                    c.save()
                except choice.DoesNotExist:
                    c = choice.objects.create(pickid=cid, pickby_id=proposer.id,cnt=1) 
                try: #if this choice is already picked for this event.
                    ec = event_choice.objects.get(event_id= e.id,choice_id=c.id)
                except:
                    ec = event_choice.objects.create(event_id=e.id, choice_id=c.id)
                item_obj = item.objects.get(id=cid)
                choice_objs.append(item_obj)
                    
            ### send a mail to inviter too, since he is the attender as well
            all_attenders = db_get_all_attender_emails(e.id)
            all_attenders.append(e.inviter)  #include the inviter

            ### send email to each attender 
            for each_attender in all_attenders:
                #remove space
                each_attender = each_attender.strip()    
                try:
                    attender = user.objects.get(email=each_attender)
                    newChoiceNotificationMail(ehash, attender.uhash, proposer.email, e.name, attender.email)
                except user.DoesNotExist:   #ignore the user which doesn't exist in the db
                    continue

            data = {'event': e, 'user':proposer,'choices':choice_objs}        
            return render_to_response('myevents/addChoiceSuccess.html', data, context_instance=RequestContext(request))
        except event.DoesNotExist or user.DoesNotExist:
            return render_to_response('myevents/error.html', {"message":"event or user does not exist"}, context_instance=RequestContext(request))      
        
      
# NOT USED 7-27 
def editEventChoice2(request, ehash, uhash):
    if request.method == "POST":
        manual_choices = request.POST.getlist('manual_choice_ids')
        #print manual_choices
        yelp_choices = request.POST.getlist('yelp_choice_ids')
        #print yelp_choices
        rec_choices = request.POST.getlist('rec_choice_ids')
        #past_choices = request.POST.getlist('history_choice_ids')
        try: 
            choice_objs = []
            e = event.objects.get(ehash=ehash)
            inviter = user.objects.get(uhash=uhash)
            for cid in manual_choices:
                try:
                    c = choice.objects.get(pickid=cid, pickfrom=CHOICE_SOURCE.MANUAL, pickby_id=inviter.id)
                    c.cnt += 1
                    c.save()
                except choice.DoesNotExist:
                    c = choice.objects.create(pickid=cid, pickfrom=CHOICE_SOURCE.MANUAL, pickby_id=inviter.id,cnt=1)                     
                try: # here is for wrong operation. shouldn't happen if not because of testing
                    ec = event_choice.objects.get(event_id= e.id,choice_id=c.id)
                except:
                    ec = event_choice.objects.create(event_id=e.id, choice_id=c.id)
                manual_c = item.objects.get(id=cid)
                choice_objs.append(manual_c)
                
            for cid in yelp_choices:
                try:
                    c = choice.objects.get(pickid=cid, pickfrom=CHOICE_SOURCE.YELP, pickby_id=inviter.id)
                    c.cnt +=1
                    c.save()
                except choice.DoesNotExist:
                    c = choice.objects.create(pickid=cid, pickfrom=CHOICE_SOURCE.YELP, pickby_id=inviter.id,cnt=1)
                try: # here is for wrong operation. shouldn't happen if not because of testing
                    ec = event_choice.objects.get(event_id= e.id,choice_id=c.id)
                except:
                    ec = event_choice.objects.create(event_id=e.id, choice_id=c.id)
                # yelp data table is separated from item.
                yelp_c = item.objects.get(id=cid)
                choice_objs.append(yelp_c)
                
            for cid in rec_choices:
                try:
                    c = choice.objects.get(pickid=cid, pickfrom=CHOICE_SOURCE.REC, pickby_id=inviter.id)
                    c.cnt +=1
                    c.save()
                except choice.DoesNotExist:
                    c = choice.objects.create(pickid=cid, pickfrom=CHOICE_SOURCE.REC, pickby_id=inviter.id,cnt=1)
                try: # here is for wrong operation. shouldn't happen if not because of testing
                    ec = event_choice.objects.get(event_id= e.id,choice_id=c.id)
                except:
                    ec = event_choice.objects.create(event_id=e.id, choice_id=c.id)
                # yelp data table is separated from item.
                rec_c = item.objects.get(id=cid)
                choice_objs.append(rec_c)
                
            ### send a mail to inviter too, since he is the attender as well
            attenderMail(ehash, inviter.uhash, inviter.email, e.name, inviter.email)
            
            ### get all friends email
            attenders = e.friends.strip()
            all_attenders = attenders.split(',')

            ### send email to each attender 
            for each_attender in all_attenders:
                #remove space
                each_attender = each_attender.strip()    
                try:
                    attender = user.objects.get(email=each_attender)
                    attenderMail(ehash, attender.uhash, inviter.email, e.name, attender.email)
                except user.DoesNotExist:   #ignore the user which doesn't exist in the db
                    continue
                
            e.status = EVENT_STATUS.VOTING
            e.save()
            data = {'event': e, 'choices':choice_objs}        
            return render_to_response('myevents/success.html', data, context_instance=RequestContext(request))
        except event.DoesNotExist or user.DoesNotExist:
            return render_to_response('myevents/error.html', {"message":"event does not exist"}, context_instance=RequestContext(request))      
          

